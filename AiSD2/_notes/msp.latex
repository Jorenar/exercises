\documentclass[12pt]{article}

\usepackage[a4paper, vmargin=15pt, hmargin=50pt, head=15pt, includehead]{geometry}

\usepackage{amsmath}     % math
\usepackage{amssymb}     % math symbols
\usepackage{enumitem}
\usepackage{xcolor}

\setlength{\parskip}{0.7em}
\setlength{\parindent}{0em}

\newcommand{\h}[1]{\colorbox{yellow}{#1}}

\begin{document}

Gdyby użyć Floyda-Warshaslla:
\begin{enumerate}
   \item Ustawiamy wagi krawędzi na 1
   \item Uruchamiamy algorytm
   \item Wyniki:
      \begin{itemize}
         \item $d_{ij} < \infty \implies $  ścieżka istnieje
         \item $d_{ij} = \infty \implies $  ścieżka nie istnieje
      \end{itemize}
\end{enumerate}

Konkretna długość ścieżki jest bezużyteczna, zatem modyfikujemy algorytm do przechowywania wartości binarnych:

$t^{(k)}_{ij}$ -- określa, czy w G istnieje ścieżka ze wszystkimi wierzchołkami pośrednimi $\{1, ..., k\}$

$t^{(0)}_{ij} := \Big( i \ne j \land (i,j) \in E  \Big)$

$t^{(k)}_{ij} := \Big( t^{(k-1)}_{ij} \lor \left(t^{(k-1)}_{ik} \land t^{(k-1)}_{kj} \right) \Big) $

\begin{verbatim}
                                  (1)    _- (2)
                                   ^   _/   ^ |
                                   |  /     | |
                                   | v      | v
                                  (4) ----> (3)
\end{verbatim}

\begin{equation*}
   T^{(0)} = \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & 1 & 1 & 1 \\
      0 & 1 & 1 & 0 \\
      1 & 0 & 1 & 1 \\
   \end{bmatrix}
\end{equation*}
\begin{equation*}
   T^{(1)} = \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & 1 & 1 & 1 \\
      0 & 1 & 1 & 0 \\
      1 & 0 & 1 & 1 \\
   \end{bmatrix}
\end{equation*}
\begin{equation*}
   T^{(2)} = \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & 1 & 1 & 1 \\
      0 & 1 & 1 & \h{1} \\
      1 & 0 & 1 & 1 \\
   \end{bmatrix}
\end{equation*}
\begin{equation*}
   T^{(3)} = \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & 1 & 1 & 1 \\
      0 & 1 & 1 & 1 \\
      1 & \h{1} & 1 & 1 \\
   \end{bmatrix}
\end{equation*}
\begin{equation*}
   T^{(4)} = \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      \h{1} & 1 & 1 & 1 \\
      \h{1} & 1 & 1 & 1 \\
      1 & 1 & 1 & 1 \\
   \end{bmatrix}
\end{equation*}

 \begin{verbatim}
   TransitiveClosure(g):
      n = |G.V|
      T^(0) = new BoolMatrix(n,n)
      for i in 1..n:
         for j in 1..n:
            T^(0) [i][j] = G.hasEdge(i,j)  ||  i==j
      for k in 1..n:
         T^(k) = new BoolMatrix(n,n)
         for i in 1..n:
            for j in 1..n:
            T^(k) [i][j] = T^(k-1) [i][j]  || ( T^(k-1) [i][k]  &&  T^(k-1) [k][j] )

      // można spokojnie użyć jednej tablicy T
 \end{verbatim}

\end{document}

% vim: spl=pl
