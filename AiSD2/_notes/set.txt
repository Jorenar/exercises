**SET**

Usually implemented on Red-Black tree, but can be done on array.

              | unsorted array | sorted array | Red-Black tree |
|-------------|----------------|--------------|----------------|
| insert(x)   |      O(n)      |   O(n)       |    O(log n)    |
| remove(x)   |      O(n)      |   O(n)       |    O(log n)    |
| isMember(x) |      O(n)      |   O(log n)   |    O(log n)    |
| pop()       |      O(1)      |   O(1)       |    O(log n)    |


First advantage of using sorted array over unsorted one is being able to execute binary search on it.
Another one are operations with O(n log n) complexity (or O(n) if we ignore sorting) instead of O(nÂ²).


===== set operations on sorted arrays =====

union_v1(S1, S2):
    R := []
    idx := 0

    while (i < |S1|) and (j < |S2|):
        if S1[i] < S2[j]:
            R[idx] := S1[i]
            i := i + 1
        elif S1[i] > S2[j]:
            R[idx] := S2[j]
            j := j + 1
        else:
            R[idx] = S1[i]
            i := i + 1
            j := j + 1

        idx := idx + 1

    while i < |S1|:
        R[idx] = S1[i]
        idx := idx + 1
    while j < |S2|:
        R[idx] := S2[j]
        idx := idx + 1

    sort(R)

    return R


union_v2(S1, S2):               // with removing duplicates
    temp := S1 + S2
    sort(temp)

    R := []
    R[0] = temp[0]

    i := 1
    idx := 1

    while i < |temp|:
        if not (temp[i] = temp[i-1]):
            R[idx] := temp[i]
        i := i + 1

    return R


intersection(S1, S2):           // no need to sort, complexity O(n)
    R := []
    idx := 0

    i := 0
    j := 0
    while (i < |S1|) and (j < |S2|):
        if S1[i] < S2[j]:
            i := i + 1
        elif S1[i] > S2[j]:
            j := j + 1
        else:
            R[idx] = S1[i]
            idx := idx + 1

            i := i + 1
            j := j + 1

    return R


difference(S1, S2):
    R := []
    idx := 0

    i := 0
    j := 0
    while (i < |S1|) and (j < |S2|):
        if S1[i] < S2[j]:
            R[idx] = S1[i]
            idx := idx + 1
            i := i + 1
        elif S1[i] > S2[j]:
            R[idx] = S2[j]
            idx := idx + 1
            j := j + 1
        else:
            i := i + 1
            j := j + 1

    while i < |S1|:
        R[idx] = S1[i]
        idx := idx + 1

    while j < |S2|:
        R[idx] = S2[j]
        idx := idx + 1

    sort(R)

    return R
